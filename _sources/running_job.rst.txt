اجرای برنامه
============

.. contents::

نمای کلی
--------

همه سرورهای محاسباتی برای اجرای برنامه‌های کاربران ``(JOB)`` از سیستم‌های مدیریت صف و منابع ``(Job scheduler)`` استفاده می‌کنند. 
از این برنامه برای ارسال برنامه‌های دسته‌ای	، نظارت و همچنین مدیریت آنها استفاده می‌شود. برنامه‌های ارسالی کاربران بر روی نودهای محاسباتی اجرا می‌شوند، و نود اصلی تنها وظیفه مدیریت منابع و برنامه‌ها را بر عهده دارد. در خوشه محاسباتی ما، نرم‌افزار ``PBS Torque`` برای اینکار در نظر گرفته شده است. طرز کار ``PBS`` به صورت شماتیک در تصویر زیر نشان داده شده‌است.

.. image:: _static/pbs.JPG

.. note:: از اینجا به بعد به جای برنامه از واژه ``JOB`` استفاده خواهد شد و بیانگر برنامه‌ای است که کاربر قصد اجرای آن را دارد.

برای دسته‌بندی ``JOB`` های مختلف از صف‌های ``(Queue)`` مختلف استفاده می‌شود. صف‌های موجود در سیستم متفاوت هستند، اما همه به طور معمول محدودیت‌هایی در حداکثر زمان اجرا ``(walltime)`` و یا تعداد هسته‌های مجاز برای اجرا دارند. بعضی از صف‌ها ممکن است محدودیت‌های دیگری نیز داشته باشند و یا محدود به سرویس‌دهی به کاربران یا گروه‌های خاص باشند.

ایجاد JOBFILE:
~~~~~~~~~~~~~~~~~

برای اجرای برنامه ابتدا باید ``JOBFILE`` مورد نظرتان را بسازید که نمونه‌ای از آن را در اینجا مشاهده می‌کنید. (این یک مثال ساده برای اجرای برنامه ``LAMMPS`` است.)

.. code-block:: BASH
	
	#!/bin/bash
	#PBS -N Name
	#PBS -j eo
	#PBS -l nodes=1:ppn=20
	#PBS -l walltime=12:00:00
	cd $PBS_O_WORKDIR

	module purge
	module load rocks-openmpi
	module load lammps/16Mar18_mpi
	mpirun -np 20 lmp_mpi < input.in > out.log

این فایل شامل تمام درخواست‌های شما از منابع سیستم و همچنین دستوراتی که مایل به اجرای آن هستید است. مفسر شل، خط‌هایی که با هشتک ``(#)`` شروع می‌شوند را به عنوان دستور شل ``(SHELL)`` در نظر نمی‌گیرد. و کاربر آن را برای توضیحات وارد اسکریپت خود می‌کند. بنmodule purge
	module load rocks-openmpiابراین تمام خطوطی که با ``PBS#`` شروع می‌شوند (خطوط قهوه‌ای رنگ)، به عنوان دستورات ``PBS`` در نظر گرفته‌شده و برای ``SHELL`` ناخوانا است.

1) خط اول، مشخص می‌کند که کدام پوسته استفاده خواهد شد. در این مثال از bash استفاده می‌شود؛ اما از csh یا سایر ‌پوسته‌ها نیز می‌توانید استفاده کنید.
2) خط دوم، نام ``JOB`` ای که در سیستم صف اجرا می‌شود را مشخص می‌کند که در اینجا ``Name`` انتخاب شده است و شما باید با توجه برنامه‌ای که اجرا می‌کنید، یک نام با معنی انتخاب کنید. این کار برای تشخصیص ``JOB`` های مختلفی که همزمان اجرا می‌شود مفید است و باعث خوانایی در صف می‌شود.
3) خط سوم، تعیین می‌کند خروجی دستورات و خطاهای برنامه را در فایلی به نام ``Name.eID`` قرار دهد که در واقع ``log`` آن است. (``Name`` نام جابی است که در بالا تعیین کرده‌اید و ``ID`` نیز یک شناسه یکتا برای ``JOB`` است که در زمام ارسال به صف اختصاص داده می‌شود.) این فایل زمانی که در ``JOB`` خطایی رخ داده‌باشد، بسیار کارآمد است.
4) خط چهام، تعداد نودها و پردازنده‌های مورد نظر برای اجرای این ``JOB`` را مشخص می‌کند. در این مثال، یک نود با 20 پردازنده درخواست شده‌است. (حتما توضیحات بیشتر را در این `قسمت <running_job.html#cores>`_ بخوانید.)
5) خط پنجم، بیان می‌کند که چه میزان زمان برای اجرای این ``JOB`` درخواست شده‌است. در این مثال 12 ساعت درخواست شده‌است. اگر زمان اجرای ``JOB`` از این میزان که تعیین کرده‌اید بیشتر شود اجرای برنامه به صورت خودکار متوقف خواهد شد. (حتما توضیحات بیشتر را در این `قسمت <running_job.html#walltime>`_ بخوانید.)
6) خط ششم، به ``PBS`` می‌گوید که به دایرکتوری که داده‌ها برای اجرای این برنامه در آن قرار دارد، دسترسی پیدا کنید. در این مثال، منظور از ``PBS_O_WORKDIR$`` پوشه‌ای است که ``JOBFILE`` از آن به سیستم ارسال شده‌است. توجه کنید که این و تمام متغیرهایی که با ``PBS$`` شروع می‌شوند، به صورت خودکار توسط ``PBS`` ایجاد می‌شوند.
7) خطوط بعدی در این مثال برای اجرای برنامه ``LAMMPS`` است و برای هر برنامه‌ای که اجرا می‌کنید متفاوت است. (توضیحات بیشتر را در این `قسمت <software_list.html>`_  بخوانید.)

.. warning:: از تگ ``cput`` در ``JOBFILE`` خود استفاده نکنید، زیرا در اجراهای موازی ایجاد مشکل خواهد کرد.


ارسال برنامه به صف:
~~~~~~~~~~~~~~~~~~~

برای ارسال برنامه باید با توجه به دستورالعمل بالا یک ``JOBFILE`` ایجاد کرده و در پوشه‌ای که می‌خواهیم برنامه داخل آن اجرا شود قرار بدهیم. بعد از آن وارد آن پوشه شده و با استفاده از دستور ``qsub`` فایل ``JOBFILE`` را به سیستم صف ارسال می‌کنیم.

.. code-block:: BASH

 qsub run.job
 
در اینجا اسم ``JOBFILE`` من ``run.job`` است و این اسم اختیاری است و هر اسمی می‌تواند باشد. در صورت موفق بودن، سیستم یک ``ID`` منحصربه‌فرد به آن اختصاص داده و نمایش خواهد داد.

.. code-block:: BASH

 10.head.cluster.ut.ac.ir

در اینجا شماره ``10`` همان ``ID`` است. 

برای مشاهده وضعیت ``JOB``، از دستور ``qstat`` استفاده کنید. خروجی این دستور به شکل زیر خواهد بود:

.. image:: _static/qstat01.png

چنان‌که درتصویر مشاهده می‌شود اطلاعات منابع استفاده شده توسط ``JOB`` و همچنین وضعیت و زمان اجرا را نشان می‌دهد. بخش مهم در خروجی این دستور، ستون دوم از آخر است که نشانگر وضعیعت ``JOB`` است و با ``S`` مشخص می‌شود. وضعیت ``R`` بیانگر در حال اجرا، وضعیت ``C`` بیانگر اتمام برنامه و وضعیت ``Q`` بیانگر این است که برنامه در صف قرار دارد. 

.. note:: اگر در ``JOBFILE`` شما خطایی رخ داده باشد که منجر به قطع اجرای برنامه بشود، در این صورت نیز وضعیت ``C`` نشان داده خواهدشد و برای بررسی این موضع می‌توانید از ``LOGFILE`` ای که برای این ``JOB`` ایجاد شده است، استفاده کنید.

به منظور متوقف کردن ``JOB`` در حال اجرا یا منتظر در صف از دستور ``qdel`` استفاده می‌کنیم:

::

 qdel 10

که در اینجا باید از ``JOB ID`` استفاده شود و همان شماره‌ای است که در دستور ``qstat`` مشخص می‌شود.

همچنین می‌توانید دستورات بیشتر در رابطه با ``PBS`` و ``maui`` را در این `لینک <_static/Additional_PBS_Maui_commands.html>`_ مشاهده کنید.




تنظیم میزان هسته‌های موردنیاز (CORES):
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

کاربران عزیر باید توجه داشته باشند که سیستم‌های پردازش سریع ``(HPC)`` از این جهت مورد استفاده محققین قرار می‌گیرند که می‌توانند همزمان تعداد زیادی هسته‌ محاسباتی را در اختیار آنان قرار دهند. بنابراین مهمترین مزیت استفاده از سیستم ``HPC`` همین موضوع است. بنابراین در این قسمت در این مورد بیشتر توضیح داده خواهد شد. 

برنامه‌های اجرای در کلاستر بنا به نحوه استفاده از هسته‌ها به دو دسته سریال و موازی طبقه بندی می‌شوند. اطلاعات بیشتر در این زمینه را از `اینجا <ـhttps://fa.wikipedia.org/wiki/%D8%B1%D8%A7%DB%8C%D8%A7%D9%86%D8%B4_%D9%85%D9%88%D8%A7%D8%B2%DB%8C>`_ بخوانید.

اجراهای سریال:
##############

برای اجرای یک برنامه سریال که بر روی یک هسته اجرا می‌شود باید تعداد هسته‌های درخواستی در ``JOBFILE`` برابر با یک و همچنین تعداد نودها نیز باید یک باشد. 

::

 #PBS -l nodes=1:ppn=1
 
کاربران باید توجه داشته باشند که همزمان هر کاربر بیشتر از 10 ``JOBFILE`` را همزمان نمی‌تواند اجرا کند. بنابراین اگر نیاز دارد تعداد بیشتری برنامه سریال را اجرا کند، بهتر است که آنها را در درون یک ``JOBFILE`` قرار بدهد. یک مثال ساده از این نوع به شکل زیر است که در آن 5 برنامه سریال مختلف در 5 پوشه مختلف به صورت همزمان در یک ``JOBFILE`` اجرا می‌شود:

.. code-block:: BASH

	#!/bin/bash
	#PBS -N run_5in1
	#PBS -j eo
	#PBS -l nodes=1:ppn=5
	#PBS -l walltime=12:00:00
	cd $PBS_O_WORKDIR

	# Simple jobfile for running 5 serial programs in one jobfile.
	cd folder1
	./exe1 &&
	cd ../folder2
	./exe2 &&
	cd ../folder3
	./exe3 &&
	cd ../folder4
	./exe4 &&
	cd ../folder5
	./exe5 &&

	wait

.. note:: توجه داشته باشید که تعداد هسته‌های درخواستی در ``ppn`` را برابر با تعداد برنامه‌های در حال اجرا قرار داده و حتما از دستور ``wait`` در آخرین خط استفاده کنید.

.. note:: اگر کاربری قصد اجرای تعداد زیادی برنامه سریال را دارد، برای افزایش بهره‌وری سیستم،‌ پیشنهاد می‌شود که از روش اشاره‌شده در بالا استفاده کرده و همه را داخل یک ``JOBFILE`` قرار دهد.


اجراهای موازی:
##############

برای اجرای یک برنامه به صورت موازی اصولا باید آن برنامه با الگوریتم موازی و یکی از روش‌های ``OpenMP``  یا ``MPI`` نوشته شده‌باشد. اطلاعات بیشتر در این زمینه را از
`OpenMP <https://en.wikipedia.org/wiki/OpenMP>`_
و
`MPI <https://en.wikipedia.org/wiki/Message_Passing_Interface>`_
بخوانید.

کامپایل برنامه‌ای که در زبان ``c++`` به صورت ``OpenMP`` نوشته شده است، به صورت زیر است. (برای فرترن نیز همین گونه است.)

.. code-block:: BASH

 g++ -fopenmp omp_hello.cpp -o omp_hello.x
 
و برای اجرا نیز ``JOBFILE`` باید به صورت زیر باشد:

 
.. code-block:: BASH

	#!/bin/bash
	#PBS -N run_OpenMP
	#PBS -j eo
	#PBS -l nodes=1:ppn=5
	#PBS -l walltime=12:00:00
	cd $PBS_O_WORKDIR

	# Simple jobfile for running openmp program with 5 cores.
	export OMP_NUM_THREADS=5
	./omp_hello.x

.. note:: توجه کنید تعداد هسته‌های درخواستی در ``ppn`` باید برابر با ``OMP_NUM_THREADS`` باشد.

.. note:: اگر نیاز به کاپایلر و یا ورژن خاصی دارید به این قسمت مراجعه کنید.


کامپایل برنامه‌ای که در زبان ``c++`` به صورت ``MPI`` نوشته شده است، به صورت زیر است. (برای فرترن نیز همین گونه است.)

.. code-block:: BASH

 mpic++ omp_hello.cpp -o omp_hello.x
 
و برای اجرا نیز ``JOBFILE`` باید به صورت زیر باشد:

 
.. code-block:: BASH

	#!/bin/bash
	#PBS -N run_MPI
	#PBS -j eo
	#PBS -l nodes=1:ppn=5
	#PBS -l walltime=12:00:00
	cd $PBS_O_WORKDIR

	# Simple jobfile for running MPI program with 5 cores.
	module purge
	module load rocks-openmpi
	mpirun -np $PBS_NP --hostfile $PBS_NODEFILE ./omp_hello.x

.. note:: توجه داشته‌باشید که متغیرهایی  ``PBS_NP$`` و ``PBS_NODEFILE$`` به صورت خودکار توسط ``PBS`` ایجاد می‌شوند و شما برای تعیین تعداد هسته‌ها برای اجرای ``mpirun`` تنها باید در خط ``PBS -l nodes=1:ppn=5`` آن‌ها را تعیین کنید. 

.. note:: توجه داشته‌باشید برای درخواست‌ اجرا در چند نود، تعداد کل هسته‌ها، حاصل‌ضرب ``ppn`` و ``nodes`` است  و در چنین اجراهایی حتما باید از تگ ``hostfile $PBS_NODEFILE--`` استفاده شود.

.. note:: توجه داشته‌باشید تعداد کل هسته‌های محاسباتی که هر کاربر به‌طور همزمان در کل اجراها، می‌تواند استفاده کند، 60 هسته است. بنابراین در یک ``JOBFILE`` نباید بیشتر از 60 هسته درخواست کنید.


تنظیم میزان زمان اجرای برنامه (WALLTIME):
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

سیستم مدیریت صف ``PBS`` با توجه به میزان منابع درخواستی من جمله تعداد پردازنده‌ها و هم چنین زمان انجام محاسبات، برنامه‌های ارسالی را اولویت‌بندی نموده و بر این اساس آن‌ها را برای اجرا به نود‌های اجرایی ارسال می‌کند. میزان زمان درخواستی برای اجرا، ``walltime`` نامیده می‌شود و هر چقدر کمتر باشد اولویت‌ بیشتری برای اجرا خواهد داشت. بنابراین با توجه به تخمینی که خودمان از برنامه داریم، باید حداقل زمان تخمینی را در ``JOBFILE`` قرار دهیم تا اولویت اجرای ``JOB`` خود را بالا ببریم. 

.. note:: اگر مدت زمان اجرای برنامه از میزان ``walltime`` درخواستی ما  بیشتر شود، آن ``JOB`` به صورت خودکار متوقف خواهد شد.

با توجه به افزایش تعداد کاربران سیستم‌ پردازش فوق سریع دانشکده فیزیک و همچنین محدودیت منابع سیستم، نیاز به اعمال محدودیت در سیاست‌های اختصاص منابع سیستم، احساس می‌گردید. از این رو محدودیت‌هایی در ``walltime`` برنامه‌های اجرایی اعمال شده‌است که شامل موارد زیر است:

- میزان زمان ``walltime`` در صف ``default`` از 0 تا 72 ساعت.
- میزان زمان ``walltime`` در صف ``stime`` از 0 تا 4 ساعت. (با اولویت بالا)
- میزان زمان ``walltime`` در صف ``ltime`` از 100 تا 240 ساعت.
- میزان زمان ``walltime`` در صف ``vltime`` از 220 تا 1000 ساعت.

در هنگام ارسال ``JOB`` به سیستم اگر نوع صف را مشخص نکنیم به صورت پیش‌فرض به صف ``default`` ارسال خواهد شد. بنابراین اگر نیاز به اجرای برنامه بیش از 72 داشته باشیم باید آن‌ها را به یکی از صف‌های ذکر شده در بالا ارسال کنیم. یعنی اگر زمان ``walltime`` تعیین شده در بازه تعیین شده آن صف مشخص قرار نگیرد، سیستم مانع از ارسال آن خواهد شد. به طور مثال اگر ``walltime`` بین  100 تا 240 ساعت باشد باید آن را به صف ``ltime`` به شکل زیر ارسال کنیم:

::

 qsub run.job -q ltime
 
و یا از تک زیر در داخل ``JOBFILE`` استفاده کنیم.

::

 #PBS -q ltime
 
کاربران باید به این نکته توجه کنند که در صورت استفاده از صف‌های ``ltime`` و ``vltime`` امکان دارد مدت زمان بیشتری را نسبت به حالت عادی در صف منتظر بمانند.
 
 

.. note:: در صورت استفاده از صف‌های ``ltime`` و ``vltime`` در هر ``JOBFILE`` بیشتر از 20 هسته محاسباتی نمی‌توانید استفاده کنید.

.. note:: اگر در زمان ارسال، میزان ``walltime`` درخواستی را تعیین نکنید، سیستم به صورت پیش‌فرض بیشترین زمان آن صف را در نظر خواهد گرفت.



